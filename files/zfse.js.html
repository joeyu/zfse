<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>zfse.js</title>
    <link rel="stylesheet" href="http://yui.yahooapis.com/3.9.1/build/cssgrids/cssgrids-min.css">
    <link rel="stylesheet" href="../assets/vendor/prettify/prettify-min.css">
    <link rel="stylesheet" href="../assets/css/main.css" id="site_styles">
    <link rel="shortcut icon" type="image/png" href="../assets/favicon.png">
    <script src="http://yui.yahooapis.com/combo?3.9.1/build/yui/yui-min.js"></script>
</head>
<body class="yui3-skin-sam">

<div id="doc">
    <div id="hd" class="yui3-g header">
        <div class="yui3-u-3-4">
                <h1><img src="../assets/css/logo.png" title=""></h1>
        </div>
        <div class="yui3-u-1-4 version">
            <em>API Docs for: </em>
        </div>
    </div>
    <div id="bd" class="yui3-g">

        <div class="yui3-u-1-4">
            <div id="docs-sidebar" class="sidebar apidocs">
                <div id="api-list">
                    <h2 class="off-left">APIs</h2>
                    <div id="api-tabview" class="tabview">
                        <ul class="tabs">
                            <li><a href="#api-classes">Classes</a></li>
                            <li><a href="#api-modules">Modules</a></li>
                        </ul>
                
                        <div id="api-tabview-filter">
                            <input type="search" id="api-filter" placeholder="Type to filter APIs">
                        </div>
                
                        <div id="api-tabview-panel">
                            <ul id="api-classes" class="apis classes">
                                <li><a href="../classes/zfse.html">zfse</a></li>
                            </ul>
                
                            <ul id="api-modules" class="apis modules">
                                <li><a href="../modules/zfse.html">zfse</a></li>
                            </ul>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="yui3-u-3-4">
                <div id="api-options">
                    Show:
                    <label for="api-show-inherited">
                        <input type="checkbox" id="api-show-inherited" checked>
                        Inherited
                    </label>
            
                    <label for="api-show-protected">
                        <input type="checkbox" id="api-show-protected">
                        Protected
                    </label>
            
                    <label for="api-show-private">
                        <input type="checkbox" id="api-show-private">
                        Private
                    </label>
                    <label for="api-show-deprecated">
                        <input type="checkbox" id="api-show-deprecated">
                        Deprecated
                    </label>
            
                </div>
            
            <div class="apidocs">
                <div id="docs-main">
                    <div class="content">
                        <h1 class="file-heading">File: zfse.js</h1>
                        
                        <div class="file">
                            <pre class="code prettyprint linenums">
                        /* Copyright 2014 Zhou Yu
                         */
                        /**
                         * Zhou&#x27;s File System Extension to the &#x27;fs&#x27; module of node.js.
                         *
                         * @module zfse
                         * @class zfse
                         * @static
                         */
                        var fs = require(&#x27;fs&#x27;);
                        var path = require(&#x27;path&#x27;);
                        
                        module.exports = {
                            &#x27;verbose&#x27;:      false,          // verbose output
                            &#x27;traverse&#x27;:     traverse,       // Traverses a directory
                            &#x27;rRmDirSync&#x27;:   rRmDirSync,     // Recursively removes a directory
                            &#x27;rRenameSync&#x27;:  rRenameSync,    // Recursively Rename all files under a directory
                            &#x27;find&#x27;:         find,           // Finds files according to a specified file name pattern
                            &#x27;copyFileSync&#x27;: copyFileSync,   // Synchronously copy a file
                            &#x27;copyDirSync&#x27;:  copyDirSync,    // Synchronously copy a directory
                        };
                        
                        /**
                         * Traverses through the specified &#x27;dir&#x27; directory tree, and apply the 
                         * specificed &#x27;callback&#x27; function to each file node with optional 
                         * &#x27;callback_arg&#x27; arguments passed to the function.
                         *
                         * @method traverse
                         * @param dir {String} The directory to traverse.
                         * @param [options] {Object} The options
                         * @param [options.depthfirst=true] {Object} Depth-first traversal.
                         * @param [options.callbackdelay=true] {Object} callback delayed.
                         * @param [callback] {Function} The callback function to call for each file node traversing through.
                         * @param [...callback_arg] The parameters to be passed to the &#x27;callback&#x27;.
                         */
                        function traverse(fpath, options, callback) {
                            var cbArgs = Array.prototype.slice.call(arguments, 3); // gets callback arguments
                            if (typeof options === &#x27;function&#x27;) {
                                callback = options;
                                options = null;
                                cbArgs = Array.prototype.slice.call(arguments, 2); // gets callback arguments
                            }
                            var base = fpath;
                            var depthfirst = true; 
                            var callbackdelay = true; 
                            for (var key in options) {
                                if (key === &#x27;depthfirst&#x27;) depthfirst = options.depthfirst;
                                if (key === &#x27;callbackdelay&#x27;) callbackdelay = options.callbackdelay;
                            }
                            
                            var _traverseDepth = function (fpath, base, callback) {
                                var cbArgs = Array.prototype.slice.call(arguments, 3); // gets callback arguments
                                
                                if (!callbackdelay) {
                                    callback.apply(undefined, [fpath, base].concat(cbArgs));
                                }
                        
                                var stat = fs.lstatSync(fpath);
                                if (stat.isDirectory()) {
                                    var files = fs.readdirSync(fpath);
                                    files.forEach(function (f) {
                                        _traverseDepth.apply(undefined, [path.join(fpath, f), base, callback].concat(cbArgs));
                                    });
                                }
                                if (callbackdelay) {
                                    callback.apply(undefined, [fpath, base].concat(cbArgs));
                                }
                            };
                        
                            var _traverseBreadth = function (fpaths, base, callback) {
                                var cbArgs = Array.prototype.slice.call(arguments, 3); // gets callback arguments
                                var nextLevel = [];
                        
                                fpaths.forEach(function (f) {
                                    if (!callbackdelay) {
                                        callback.apply(undefined, [f, base].concat(cbArgs));
                                    }
                        
                                    var stat = fs.lstatSync(f);
                                    if (stat.isDirectory()) {
                                        nextLevel = nextLevel.concat(fs.readdirSync(f).map(function(e) {return path.join(f, e)}));
                                    }
                                });
                        
                        
                                if (nextLevel.length &gt; 0) {
                                    _traverseBreadth.apply(undefined, [nextLevel, base, callback].concat(cbArgs));
                                }
                        
                                if (callbackdelay) {
                                    fpaths.forEach(function (f) {
                                        callback.apply(undefined, [f, base].concat(cbArgs));
                                    });
                                }
                            };
                        
                            if (depthfirst) {
                                _traverseDepth.apply(undefined, [fpath, base, callback].concat(cbArgs));
                            }
                            else {
                                _traverseBreadth.apply(undefined, [[fpath], base, callback].concat(cbArgs));
                            } 
                        }
                        
                        
                        /**
                         * Recursively removes a directory. This function works in a similar way as linux 
                         * shell command &#x27;rm -rf&#x27;. 
                         * If &#x27;dir&#x27; is single file, this function works in the same way as fs.unlinkSync()
                         *
                         * @method rRmDirSync
                         * @param dir {String} The directory to remove.
                         * @param [options] {Object} Options when running this function.
                         * @param [options.dryrun=false] {Boolean} Dry-runs the function w/o actually renaming.
                         */
                        function rRmDirSync(dir, options) {
                            var dryrun = false;
                        
                            for (var key in options) {
                                if (key === &#x27;dryrun&#x27;) dryrun = options.dryrun;
                            }
                        
                            traverse(dir, function (fpath) {
                                if (module.exports.verbose) {
                                    console.log(fpath);
                                }
                                var stat = fs.lstatSync(fpath);
                                if (stat.isDirectory()) {
                                    if (!dryrun) {
                                        fs.rmdirSync(fpath);
                                    }
                                }
                                else {
                                    if (!dryrun) {
                                        fs.unlinkSync(fpath);
                                    }
                                }
                            });
                        }
                        
                        /**
                         * Recursively renames files matching the &#x27;oldNamePattern&#x27; regex to &#x27;newName&#x27;.
                         * This function works a a similar way as linux shell command &#x27;find -name oldNamePattern -exec mv \{\} newName \;&#x27;.
                         * 
                         * @method rRenameSync
                         * @param dir {String} The directory from which search starts.
                         * @param oldNamePattern {RegExp} Search pattern in regular expression.
                         * @param newName {String} The new name.
                         * @param [options] {Object} Options when running this function.
                         * @param [options.dryrun=false] {Boolean} Dry-runs the function w/o actually renaming.
                         */
                        function rRenameSync(dir, oldNamePattern, newName, options) {
                            var dryrun = false;
                        
                            for (var key in options) {
                                if (key === &#x27;dryrun&#x27;) dryrun = options.dryrun;
                            }
                        
                            traverse(dir, function (fpath) {
                                var basename = path.basename(fpath);
                                var dirname = path.dirname(fpath);
                                var basename2 = basename.replace(oldNamePattern, newName);
                                if (basename2 !== basename) {
                                    var fpath2  = path.join(dirname, basename2);
                                    if (module.exports.verbose) {
                                        console.log(&quot;%s --&gt; %s&quot;, fpath, fpath2);
                                    }
                                    if (!dryrun) {
                                        fs.renameSync(fpath, fpath2);
                                    }
                                }
                            });
                        }
                        
                        /**
                         * Searches the specified directory &#x27;dir&#x27; for an optionally specified &#x27;namePattern&#x27; 
                         * file name pattern, calling the &#x27;callback&#x27; function with &#x27;callback_arg&#x27; arguments
                         * if specified.
                         *
                         * @method find
                         * @param dir {String} The directory from which search starts.
                         * @param namePatten {RegExp} Search pattern in regular expression.
                         * @param [callback] {Function} The callback funtion to run for each file node that is found
                         * @param [...callback_arg] The parameters to be passed to the &#x27;callback&#x27;.
                         */
                        function find(dir, namePattern, callback) {
                            var cbArgs = Array.prototype.slice.call(arguments, 3); // gets callback arguments
                            if (typeof namePattern === &#x27;function&#x27;) {
                                callback = namePattern; // no namePattern, but callback only
                                namePattern = null;
                                cbArgs = Array.prototype.slice.call(arguments, 2); // gets callback arguments
                            }
                            traverse (dir, {&#x27;depthfirst&#x27;: false, &#x27;callbackdelay&#x27;: false}, function (fpath) {
                                var found = false;
                                if (namePattern) {
                                    var basename = path.basename(fpath);
                                    if (namePattern.exec(basename)) {
                                        found = true;
                                    }
                                }
                                else { //matched anything
                                    found = true;
                                }
                        
                                if (found) {
                                    if (callback) {
                                        callback.apply(undefined, [fpath, dir].concat(cbArgs));
                                    }
                        
                                    if (module.exports.verbose) {
                                       console.log(fpath);
                                    }
                                }
                            });
                        }
                        
                        /**
                         * Synchronously copy a file.
                         * If the destination is a directory, the source file copy will be copied to it with the
                         * same file name.
                         *
                         * @method copyFileSync
                         * @param src {String} The source file.
                         * @param dst {String} The destination file, or directory.
                         * @param [options] {Object} Options.
                         */
                        function copyFileSync(src, dst, options) {
                            var stat;
                            if (!fs.existsSync(src)) {
                                throw &quot;File doesn&#x27;t exists!&quot;;
                            }
                        
                            stat = fs.lstatSync(src);
                            if (!stat.isFile()) {
                                throw &quot;Not file!&quot;;
                            }
                            if (fs.existsSync(dst)) {
                                stat = fs.lstatSync(dst);
                                if (stat.isDirectory()) {
                                    dst += path.join(dst, path.basename(src));
                                }
                            }
                            var blksize = stat.blksize;
                            var fdSrc = fs.openSync(src, &#x27;r&#x27;);
                            var fdDst = fs.openSync(dst, &#x27;w&#x27;);
                            var buf = new Buffer(blksize);
                            var n;
                            while (n = fs.readSync(fdSrc, buf, 0, blksize, null)) {
                                if (n !== fs.writeSync(fdDst, buf, 0, n, null)) {
                                    throw &quot;Write file failed!&quot;;
                                }
                            }
                            fs.closeSync(fdSrc);
                            fs.closeSync(fdDst);
                        
                            if (module.exports.verbose) {
                                console.log(&quot;Copied &#x27;%s&#x27; to &#x27;%s&#x27;.&quot;, src, dst);
                            }
                        }
                            
                        /**
                         * Synchromously copy a directory.
                         *
                         * @method copyDirSync
                         * @param src {String} The source directory.
                         * @param dst {String} The destination directory.
                         * @param [options] {Object} Options.
                         */
                        function  copyDirSync(src, dst, options) {
                            var stat;
                            if (!fs.existsSync(src)) {
                                throw &quot;File doesn&#x27;t exists!&quot;;
                            }
                        
                            stat = fs.lstatSync(src);
                            if (!stat.isDirectory()) {
                                throw &quot;Not Directory!&quot;;
                            }
                            if (fs.existsSync(dst)) {
                                stat = fs.lstatSync(dst);
                                if (!stat.isDirectory()) {
                                    throw &quot;Not Directory!&quot;;
                                }
                            }
                        
                            traverse(src, {&#x27;callbackdelay&#x27;: false}, function (fpathSrc, baseSrc) {
                                var fpathDst = path.join(dst, path.relative(baseSrc, fpathSrc));
                                var stat = fs.lstatSync(fpathSrc);
                                if (stat.isFile()) {
                                    copyFileSync(fpathSrc, fpathDst);
                                }
                                else if (stat.isDirectory()) {
                                    fs.mkdirSync(fpathDst);
                                }
                            });
                        }
                        
                        
                            </pre>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script src="../assets/vendor/prettify/prettify-min.js"></script>
<script>prettyPrint();</script>
<script src="../assets/js/yui-prettify.js"></script>
<script src="../assets/../api.js"></script>
<script src="../assets/js/api-filter.js"></script>
<script src="../assets/js/api-list.js"></script>
<script src="../assets/js/api-search.js"></script>
<script src="../assets/js/apidocs.js"></script>
</body>
</html>
